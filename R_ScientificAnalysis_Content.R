# Working through content to see if I want to use for my teaching demo
# R for Reproducible Scientific Analysis - Exploring Data Frames
# The lesson I want to consider is 5 (Exploring Data Frames), but I'm working through Lessons 1-5 below

# https://swcarpentry.github.io/r-novice-gapminder/01-rstudio-intro.html

##  LESSON 1: INTRODUCTION TO R AND RSTUDIO

1+100
# running code, Command + Return (MAC); Control + Return (WINDOWS)
# if you get + in the console, hit esc
# order of operations same as in school, from highest to lowest precedence: 
# parentheses (,)
# exponents: ^ or **
# multiply: *
# divide: /
# add: + 
# substract: -
3+5*2
# use parentheses to group operations differently
(3+5) * 2
# really large or small numbers gets scientific notation
2/10000
# you can write in scientific notation
5e3

# Functions take arguments as inputs; anything we type inside the parentheses is considered an argument; number of arguments may vary from none to multiple

getwd() #doesn't require any input
sin(1) #requires input
log(1) #requires input
log10(10) #requires input
exp(0.5) #requires input
?exp #getting help

# Comparing Things

1==1 #equality (== reads as "is equal to")
1!=2 #inequality (!= reads as "is not equal to")
1<2
1<=2 #less than or equal to
1>0
1>=-9 #greater than or equal to

# Variables and Assignment

x <- 1/40
x
log(x)
x <- 100 #x is now reassigned
#the right-hand side of the assignment operator is fully evaluated before the assignment occurs

#variable names can contain letters, numbers, underscores, and periods but not spaces; variable names can't start with a number or an underscore
#variables beginning with a period are HIDDEN VARIABLES; GOOD REMINDER! 
#some people do periods.between.words
#some people do underscores_between_words
#some people do camelCaseToSeparateWords ; whatever you do, be consistent

# Vectorization
#R is vectorized, meaning that variables and functions can have vectors as values
#In contrast to physics and mathematics, a vector in R describes a set of values in a certain order of the same data type

1:5
2^(1:5)
x<- 1:5
2^x

# Managing your Environment
ls() #will list all variables and functions stored in the global environment
#like in the shell, ls() won't show hidden variables (".") by default
ls(all.names = TRUE) #will show all objects; GOOD TO KNOW! 

ls #what happens if you run ls without parentheses? Prints a bunch of code instead of list of objects. Why? 
#like everything in R, ls is the name of an object and when you run the name of an object, it prints the contents; the contents in this case are the R code that makes the ls function work; GOOD TO KNOW!

rm(x) #use to remove objects you no longer need

#if you have lots of things in your environment and want to delete all of them, you can pass the results of ls to the rm function
#like order of operations, anything inside the innermost parentheses is evaluated first, and so on; GOOD TO REMEMBER! 
rm(list = ls())

# R Packages
installed.packages() #to see what packages are installed
install.packages("packagename") #to install package
update.packages() #to update package
remove.packages("packagename") #to remove package
library(package) #to make package available for use

##  LESSON 2: PROJECT MANAGEMENT WITH RSTUDIO

#How to create a self-contained project (I already do this)

#Best practices for project organization

#Treat data as read only - working with data interactively (e.g., Excel) where it can be modified means you are never sure of where the data came from, or how it has been modified; treat your data as read only

#Data cleaning - in many cases, your data will be "dirty" and need significant preprocessing to get into a format R will find useful; this task is sometimes called "data munging" (never heard of that); storing these scripts in a separate folder, and creating a second "read-only" data folder to hold the "cleaned" data sets can prevent confusion between the two sets

#Treat generated output as disposable - anything generated by your scripts should be treated as disposable; it should be able to be regenerated from your scripts; some recommendations - "doc" for text docs, "data" for raw data and metadata, "results" for files generated, "src" for scripts and programs, "bin" programs from elsewhere

#Version control - important to use with projects

##  LESSON 3: SEEKING HELP

?function_name
help(function_name)

?write.table()
?write.csv() #related functions often retrieve the same help file
#you can highlight example run and command+enter and it will run 

#for help with special operators, use quotes
?"<-"

#many packages come with vignettes (tutorials and extended example documentation)
vignette() #will list all vignettes for all installed packages
vignette(package = "dplyr") #will list all vignettes for that package

#R cheatsheets: https://posit.co/resources/cheatsheets/

??function_name #does a fuzzy search (approximate string match)
??set

#Getting help via Stack Overflow
?dput
sessionInfo() #to get info on your R setup; your current R version and loaded packages

##  LESSON 4: DATA STRUCTURES

cats <- data.frame(coat = c("calico", "black", "tabby"), 
                   weight = c(2.1, 5.0, 3.2), 
                   likes_string = c(1, 0, 1))

?write.csv

#note: I manually created a data folder within the project folder before running the code below (not sure if I needed to)
write.csv(x = cats, file = "data/feline-data.csv", row.names = FALSE) #now saving the object cats as a csv file

#load in R
cats <- read.csv(file = "data/feline-data.csv")
View(cats)

#Check your data for Factors: R's default way for handing textual data has changed. Previously it automatically interpreted a factor. There is an easier character format. In most cases, factors are not needed and complicate your life, which is why newer versions of R read in text as "character". Check now to see if your version of R automatically creater factors and convert them to character format

#NOTE: For R versions > 4.0, text data is no longer converted to factors

str(cats) #check the data types; no factors, I have character, numeric, integer

#Explore the dataset by pulling out columns
cats$weight
cats$coat

cats$weight + 2 #SK: this adds 2 to every component

paste("My cat is", cats$coat) #REMEMBER; this prints "My cat is calico" "My cat is black" "My cat is tabby"

cats$weight + cats$coat #doesn't work, different data types

typeof(cats$weight) #REMEMBER FUNCTION typeof; there are double(numeric), integer, complex, logical, character

typeof(3.14) #double
typeof(1L) #the L forces the number to be an integer, since by default R uses float numbers
typeof(1) #double
typeof(1+1i) #complex
typeof(TRUE) #logical
typeof("banana") #character

#adding another cat to the dataset

?file.show
file.show("data/feline-data_v2.csv") #this does not exist

#I'm going to create it this way
cats <- data.frame(coat = c("calico", "black", "tabby", "tabby"), 
                   weight = c(2.1, 5.0, 3.2, 2.3 or 2.4), #it won't read in like this because it needs the weights to be character due to the 4th one
                   likes_string = c(1, 0, 1, 1)) 

cats <- data.frame(coat = c("calico", "black", "tabby", "tabby"), 
                   weight = c(2.1, 5.0, 3.2, "2.3 or 2.4"), 
                   likes_string = c(1, 0, 1, 1)) 
str(cats) #now weight is a character
#R wants everything in a column to be the same type

#made our point now reading the original file back in
cats <- read.csv(file = "data/feline-data.csv")

# Vectors and Type Coercion

my_vector <- vector(length = 3)
my_vector #Console: FALSE FALSE FALSE         
#A vector in R is an ordered list of things with the understanding that everything in the vector must be the same data type; NOTE: If you don't choose the datatype, it'll default to LOGICAL
another_vector <- vector(mode = "character", length = 3)
another_vector #Console: "" "" "" 
str(another_vector) #Console: chr [1:3] "" "" ""; note: 1:3 is the indexes of the vector

str(cats$weight)
#The columns of data we load into R data.frames are ALL VECTORS, and that's the root of why R forces everything in a column to be the same basic data type

#Coercion by combining vectors
combine_vector <- c(2, 6, 3)
combine_vector
str(combine_vector)

#When R encounters a mix of data types (in a column), it will force everything into one data type; SK: think about importing messy datasets and why it's always so important to check data types for all variables
quiz_vector <- c(2, 6, '3')
str(quiz_vector) #R automatically turned this into a character vector

coercion_vector <- c('a', TRUE)
str(coercion_vector) #this is a character vector too

another_coercion_vector <- c(0, TRUE)
another_coercion_vector
str(another_coercion_vector) #numeric vector

#Type Hierarchy
# Coercion rules go: logical -> integer -> double(numeric) -> complex -> character, where -> can be read as transformed into. For example, combining logical and character transforms the result to character

c('a', TRUE) #console: "a" "TRUE"
# a quick way to recognize character vectors are the "quotes" printed in the console

#forcing coercion with .as

character_vector_example <- c('0', '2', '4')
character_vector_example #character

character_coerced_to_double <- as.double(character_vector_example)
character_coerced_to_double #numeric

double_coerced_to_logical <- as.logical(character_coerced_to_double)
double_coerced_to_logical #logical

cats$likes_string #1 0 1
#turning that logical
cats$likes_string <- as.logical(cats$likes_string)
cats$likes_string #T F T

#Some Basic Vector Functions
#The combine function c() will also append things to an existing vector

ab_vector <- c('a', 'b')
ab_vector

combine_example <- c(ab_vector, "SWC")
combine_example #Console: "a" "b" "SWC"

mySeries <- 1:10
mySeries
seq(10)
seq(1, 10, by = 0.1)

sequence_example <- 20:25
head(sequence_example, 2)
tail(sequence_example, 4)

length(sequence_example) #6
typeof(sequence_example) #integer

#we can get individual elements of a vector by using brackets
first_element <- sequence_example[1]
first_element

## NOTE: To change a single element, use the bracket on the other side of the arrow: 
sequence_example[1] <- 30
sequence_example #that's cool

# Lists
#everything in a vector has to be the same data type, but you can have different data types in a list
list_example <- list(1, "a", TRUE, 1+4i)
list_example
str(list_example) #list of 4; number 1, chr "a", logi TRUE, cplx 1+4i

#to retrieve one of the elements of a list, use the double bracket
list_example[[2]] #console: "a"

#the elements of lists can also have names; prepend to the values, separated by equals
another_list <- list(title = "Numbers", numbers = 1:10, data = TRUE)
another_list
#this results in a named list and we have a new function; we can access single elements another way
another_list$title

# Names - metadata stuck to the object like a label (called an attribute in R)
# Accessing vectors and lists by name
#you've seen how to generate a named list, generating a named vector is very similar
pizza_price <- c(pizzasubito = 5.64, pizzafresh = 6.60, callapizza = 4.50)
#way to retrieve elements is different
pizza_price["pizzasubito"]
#the list approach (below) will not work
pizza_price$pizzasubito #console: ERROR; operator $ is invalid for atomic vectors
#Remember this error: it's telling you that you are trying to access something like it's in a list, but it's a vector

# Accessing and changing names
#if you are only interested in the names, use the names() function
names(pizza_price)
#we have seen how to access and change single elements of a vector; the same is possible for names
names(pizza_price) [3]
names(pizza_price) [3] <- "call-a-pizza"
pizza_price
typeof(names(pizza_price))
str(pizza_price)

# Data Frames